/*
// Copyright 2017 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the “License”); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// This file was modified by the Chair of Electronic Design Automation, TUM
*/

SECTIONS
{
  /* Place tohost and fromhost into a dedicated .tohost section */
  .tohost 0x11100000 : {
    KEEP(*(.tohost))
    LONG(0)         /* reserve 4 bytes for tohost */
  }

  .fromhost 0x11101040 : {
    KEEP(*(.fromhost))
    LONG(0)         /* reserve 4 bytes for fromhost */
  }
}

ENTRY(_start)
SEARCH_DIR(.)

MEMORY
{
  ROM  (rx)  : ORIGIN = @MEM_ROM_ORIGIN@, LENGTH = @MEM_ROM_LENGTH@
  RAM  (rw) : ORIGIN = @MEM_RAM_ORIGIN@, LENGTH = @MEM_RAM_LENGTH@
}

/* minimum sizes for heap and stack. It will be checked that they can fit on the RAM */
__stack_size     = @MIN_STACK_SIZE@;
__heap_size      = @MIN_HEAP_SIZE@;


SECTIONS
{
  /* ================ ROM ================ */

  .text : {
    KEEP(*(.text._start))
    *(.text .text.* )
  }  > RAM

  .rodata : ALIGN(4) {
    *(.rodata .rodata.*)
  } > RAM
  .srodata : ALIGN(4) {
    *(.srodata .srodata.*)
  } > RAM



  /* ================ RAM ================ */

  .init_array : ALIGN(4) {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(.init_array .init_array.*))
    PROVIDE_HIDDEN (__init_array_end = .);
  } > RAM
  .fini_array : ALIGN(4) {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(.fini_array .fini_array.*))
    PROVIDE_HIDDEN (__fini_array_end = .);
  } > RAM

  .gcc_except_table : ALIGN(4) {
    *(.gcc_except_table .gcc_except_table.*)
  } > RAM

  .eh_frame : ALIGN(4) {
    KEEP (*(.eh_frame))
  } > RAM

  __data_start = .;
  .data : ALIGN(4) {
      *(.data .data.*)
  } > RAM
  __sdata_start = .;
  .sdata : ALIGN(4) {
      *(.sdata .sdata.*)
  } > RAM

  __bss_start = .;
  .sbss : ALIGN(4) {
      *(.sbss .sbss.*)
  } > RAM
  .bss : ALIGN(4) {
      *(.bss .bss.*)
  } > RAM
  _end = .;

  /* do not place anything after this address, because the heap starts here! */

  /* point the global pointer so it can access sdata, sbss, data and bss */
  __global_pointer$ = MIN(__sdata_start + 0x800, MAX(__data_start + 0x800, _end - 0x800));

  # Stack region
  . = ALIGN(16);
  PROVIDE(_init_stack_top = . + 0x1000);

  # Heap region
  PROVIDE(_kernel_heap_bottom = _init_stack_top);
  PROVIDE(_kernel_heap_top = ORIGIN(RAM) + LENGTH(RAM));
  PROVIDE(_kernel_heap_size = _kernel_heap_top - _kernel_heap_bottom);
}
